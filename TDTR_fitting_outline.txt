#MATH
#Jiang's, Qian's, and Yanga's "Tutorial, Time-domain thermoreflectance (TDTR) for thermal property characterization of bulk and thin film materials"
#Váµ¢â‚™(tğ˜¥)  =   Â½  Î£ (Î”T(Ï‰â‚€+n*Ï‰â‚›)+Î”T(-Ï‰â‚€+n*Ï‰â‚›))*exp(i*n*Ï‰â‚›*tğ˜¥) ; n from -âˆ to âˆ			#Jiang eq 2.21 
#Vâ‚’áµ¤â‚œ(tğ˜¥) = -i*Â½ Î£ (Î”T(Ï‰â‚€+n*Ï‰â‚›)-Î”T(-Ï‰â‚€+n*Ï‰â‚›))*exp(i*n*Ï‰â‚›*tğ˜¥) ; n from -âˆ to âˆ			#Jiang eq 2.22
#	Ï‰â‚€ and Ï‰ğ˜´  are modulation frequency and laser pulse frequency 				#Jiang eq 2.10+
#	Î”T(Ï‰)=Aâ‚ âˆ« Äœ(k,Ï‰)*exp(-Ï€Â²*kÂ²*wâ‚€Â²)*2*Ï€*k*dk ; from 0 to âˆ				#Jiang eq 2.18
#		Aâ‚ is pump power average 							#Jiang eq 2.10+
#		wâ‚€=âˆš(Â½(wâ‚Â²+wâ‚‚Â²)) 								#Jiang eq 2.18+
#		Äœ(k,Ï‰)=-D/C 									#Jiang eq 2.9
#			[N]â‚™[M]â‚™...[R]â‚[N]â‚[M]â‚=|A B| where 1 is upper, n is lower		#Jiang eq 2.8
#						|C D|
#				[N]=| 1  1 | |exp(Î»*L)   0   |					#Jiang eq 2.5
#				    |-Î³áµ¢ Î³áµ¢| |  0   exp(-Î»*L)|
#				[M]=_1_   |Î³áµ¢ -1|						#Jiang eq 2.6
#				   (2*Î³áµ¢) |Î³áµ¢  1|
#				[R]=|1 -1/G|							#Jiang eq 2.7
#				    | 0  1 |
#					Î³=Kğ˜»*Î»							#Jiang eq 2.4+
#					Î»Â²=4*Ï€Â²*kÂ²*Î·+i*Ï‰*C/Kğ˜»					#Jiang eq 2.2+
#					Î·=Kğ˜³/Kğ˜»							#Jiang eq 2.1+
#OR, use: Schmidt's, Chen's, and Chen's "Pulse accumulation, radial heat conduction, and anisotropic thermal conductivity in pump-probe transient thermoreflectance"
#Z(Ï‰)=Î² Qâ‚šáµ¤ Qâ‚šáµ£ / TÂ² Î£ H(Ï‰â‚’+k*Ï‰â‚›)*exp(i*k*Ï‰â‚›*t) ; k from -âˆ to âˆ 				#Schmidt eq 5
#	H(Ï‰)= Aâ‚€ / (2*Ï€) âˆ« k (-D/C) exp(-kÂ²(wâ‚€Â²+wâ‚Â²)/8) dk ; from 0 to âˆ			#Schmidt eq 15
#			[M]â‚™...[M]â‚=|A B| where 1 is upper, n is lower				#Schmidt eq 11
#				    |C D|
#				[M]=|   cosh(q*d)    -1 / Ïƒğ‘§*q sinh(q*d) |			#Schmidt eq 10
#				    | -Ïƒğ‘§*q sinh(q*d)      cosh(q*d)     |
#					qÂ²=Ïƒğ˜³*kÂ²+Ï*c*i*Ï‰ / Ïƒğ‘§					#Schmidt eq 13

#Computationabe aware: pregenSetup() populates arrays with Î”T(Â±Ï‰â‚€+n*Ï‰â‚›) for a list of n values. it is far more efficient to do this once, rather than again each time Vin() or Vout() are called.	

#OPERATION:
#solve() < TDTR_fitting.py
#	importFile()
#	curve_fit() #fitting function: takes datapoints, and repeatedly calls child function which generates a curve, testing the passing of various args until a match is found
#		decayFunc() -> generates decay curve from tp
#			setTofitVals() -> sets values in tp
#			pregenSetup -> sets up mathematical helpers (matrices for range of n values for example)
#			for t in ts: call Vin() Vout() -> comute in and out of phase signal

#solveSimultaneous() < TDTR_fitting.py
#	for each file: call importFile()
#	least_squares() #minimization function: repeatedly calls child function which generates datapoints, testing the passing of various args until a minimum lsq is found
#		solveSimultHelper() -> generates error (data-calculated) which we want minimized, compared against curve_fit accepting the data+func, we need to handle the diffing of the two outselves for least_squares. 
#			for each file: call decayFunc()
#				... [identical to solve>curve_fit>decayFunc>...]

#solveKZF() < TDTR_fitting_KZF
#	curve_fit()
#		decayKZF() -> only difference from solve>curve_fit>decayFunc>... in that we outsource updating of tp, instead of letting decayFunc do it
#			popPropmatKZF() -> update tp (slice middle layer(s) and update
#				KZF() -> here we define what K should be as a function of depth. [edit this to swap in a different function]
				KZFother() -> here we define other params you may want to edit [edit this to swap in a different function]
#			decayFunc()
#				pregenSetup()
#				for t in ts: call Vin() Vout()

#solveKZFSimult()
	for each file: call importFile()
	least_squares()
		mG2helper()
			for each file: call decayKZF()

proposed:
solve():
	if type(fileToRead)==str
		fileToRead=[fileToRead] #cast to list, for all simultaneous-supporting following code
	if KZF=False:
		solve() #copied from solveSimultaneous. original "solve" deprecated
	else:
		solveKZF() #copied from solveKZFSimult(), original solveKZF deprecated
	
		



